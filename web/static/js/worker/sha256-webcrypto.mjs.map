{
  "version": 3,
  "sources": ["../../../js/worker/sha256-webcrypto.ts"],
  "sourcesContent": ["const encoder = new TextEncoder();\n\nconst calculateSHA256 = async (input: string) => {\n  const data = encoder.encode(input);\n  return await crypto.subtle.digest(\"SHA-256\", data);\n};\n\nconst toHexString = (byteArray: Uint8Array) => {\n  return byteArray.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n};\n\naddEventListener(\"message\", async ({ data: eventData }) => {\n  const { data, difficulty, threads } = eventData;\n  let nonce = eventData.nonce;\n  const isMainThread = nonce === 0;\n  let iterations = 0;\n\n  const requiredZeroBytes = Math.floor(difficulty / 2);\n  const isDifficultyOdd = difficulty % 2 !== 0;\n\n  for (; ;) {\n    const hashBuffer = await calculateSHA256(data + nonce);\n    const hashArray = new Uint8Array(hashBuffer);\n\n    let isValid = true;\n    for (let i = 0; i < requiredZeroBytes; i++) {\n      if (hashArray[i] !== 0) {\n        isValid = false;\n        break;\n      }\n    }\n\n    if (isValid && isDifficultyOdd) {\n      if ((hashArray[requiredZeroBytes] >> 4) !== 0) {\n        isValid = false;\n      }\n    }\n\n    if (isValid) {\n      const finalHash = toHexString(hashArray);\n      postMessage({\n        hash: finalHash,\n        data,\n        difficulty,\n        nonce,\n      });\n      return; // Exit worker\n    }\n\n    nonce += threads;\n    iterations++;\n\n    /* Truncate the decimal portion of the nonce. This is a bit of an evil bit\n     * hack, but it works reliably enough. The core of why this works is:\n     * \n     * > 13.4 % 1 !== 0\n     * true\n     * > 13 % 1 !== 0\n     * false\n     */\n    if (nonce % 1 !== 0) {\n      nonce = Math.trunc(nonce);\n    }\n\n    // Send a progress update from the main thread every 1024 iterations.\n    if (isMainThread && (iterations & 1023) === 0) {\n      postMessage(nonce);\n    }\n  }\n});"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAAA,IAAMA,EAAU,IAAI,YAEdC,EAAkB,MAAOC,GAAkB,CAC/C,IAAMC,EAAOH,EAAQ,OAAOE,CAAK,EACjC,OAAO,MAAM,OAAO,OAAO,OAAO,UAAWC,CAAI,CACnD,EAEMC,EAAeC,GACZA,EAAU,OAAO,CAACC,EAAKC,IAASD,EAAMC,EAAK,SAAS,EAAE,EAAE,SAAS,EAAG,GAAG,EAAG,EAAE,EAGrF,iBAAiB,UAAW,MAAO,CAAE,KAAMC,CAAU,IAAM,CACzD,GAAM,CAAE,KAAAL,EAAM,WAAAM,EAAY,QAAAC,CAAQ,EAAIF,EAClCG,EAAQH,EAAU,MAChBI,EAAeD,IAAU,EAC3BE,EAAa,EAEXC,EAAoB,KAAK,MAAML,EAAa,CAAC,EAC7CM,EAAkBN,EAAa,IAAM,EAE3C,OAAU,CACR,IAAMO,EAAa,MAAMf,EAAgBE,EAAOQ,CAAK,EAC/CM,EAAY,IAAI,WAAWD,CAAU,EAEvCE,EAAU,GACd,QAASC,EAAI,EAAGA,EAAIL,EAAmBK,IACrC,GAAIF,EAAUE,CAAC,IAAM,EAAG,CACtBD,EAAU,GACV,KACF,CASF,GANIA,GAAWH,GACRE,EAAUH,CAAiB,GAAK,IAAO,IAC1CI,EAAU,IAIVA,EAAS,CACX,IAAME,EAAYhB,EAAYa,CAAS,EACvC,YAAY,CACV,KAAMG,EACN,KAAAjB,EACA,WAAAM,EACA,MAAAE,CACF,CAAC,EACD,MACF,CAEAA,GAASD,EACTG,IAUIF,EAAQ,IAAM,IAChBA,EAAQ,KAAK,MAAMA,CAAK,GAItBC,IAAiBC,EAAa,QAAU,GAC1C,YAAYF,CAAK,CAErB,CACF,CAAC",
  "names": ["encoder", "calculateSHA256", "input", "data", "toHexString", "byteArray", "str", "byte", "eventData", "difficulty", "threads", "nonce", "isMainThread", "iterations", "requiredZeroBytes", "isDifficultyOdd", "hashBuffer", "hashArray", "isValid", "i", "finalHash"]
}
